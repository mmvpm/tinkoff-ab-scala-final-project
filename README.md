# Final Project

---

UPD: Комментарий к решению оставил в [solution.md](solution.md)

---

Переход с монолитной архитектуру на микросервисную таит в себе множество подводных камней. За повышенную гибкость и
масштабируемость приходится платить сетевыми задержками и сложностями в межсервисном взаимодействии.

Типичная проблема при разработке микросервисной архитектуры — администрирование распределенных транзакций. При
монолитной архитектуре все запросы можно поместить в единую транзакцию, поскольку база данных — общая. Современные базы
данных предоставляют нам [ACID](https://en.wikipedia.org/wiki/ACID)
или [BASE](https://en.wikipedia.org/wiki/Eventual_consistency) гарантии, по которым мы можем судить о консистентности
наших данных.

Соответственно, при переходе к микросервисной архитектуре, мы теряем эти гарантии на глобальном уровне. Однако, не всё
так плохо — существуют подходы, которые позволяют нам эти гарантии сохранить.

---

Всего выделяют [четыре](https://microservices.io/post/patterns/2023/07/29/service-collaboration-patterns.html) таких
шаблона (у них есть общий термин — _service collaboration patterns_).

Два из них помогают реализовать межсервисные "приказы":

- Saga
- Command-side replica

Другие два применимы при агрегации данных:

- API Composition
- CQRS

![service collaboration patterns](https://microservices.io/i/patterns/data/service-collaboration-patterns.png)

---

В этом задании, мы разберем по одному подходу из каждой группы.

Из выбранной пары шаблонов проектирования для администрирования распределенных транзакций, вам предлагается
реализовать **всего лишь один**:

- [1. Saga: Choreography](#option-1-saga-choreography)
- [2. CQRS](#option-2-cqrs)

## Option 1. Saga: Choreography

![Saga: Choreography](https://microservices.io/i/sagas/Create_Order_Saga.png)

---

**Saga (сага)** реализует распределенную транзакцию через последовательность _локальных_ транзакций.

Каждая локальная транзакция вносит изменения в локальную базу данных и публикует сообщение, которое запускает следующую
локальную транзакцию. Rollback-и обрабатываются через "компенсирующие" транзакции.

---

Существует два способа реализации саги — _хореография_ (choreography) и _оркестрация_ (orchestration).

При хореографии, каждая локальная транзакция запускает следующую. В итоге получается цепочка вызовов — от координатора,
через всех участников саги, и обратно к координатору, чтобы подтвердить успешность транзакции.

При оркестрации, координатор самостоятельно отвечает за запуск локальных транзакций. В таком случае отпадает прямое
взаимодействие между сервисами, однако вся ответственность за запуск и компенсацию транзакций в таком случае ложится на
сервис-оркестратор.

---

В этом варианте, вам предстоит реализовать сага-**хореографию** для двух REST API сервисов и одного
сервиса-координатора.

[Нажми, чтобы перейти к продолжению](#transactional-outbox)

---

Справка:

- https://microservices.io/patterns/data/saga.html

## Option 2. CQRS

![CQRS](https://microservices.io/i/patterns/data/QuerySideService.png)

---

Аналогично тому, как сага представляет распределенную транзакцию через серию локальных транзакций, **Command Query
Responsibility Segregation (CQRS)** представляет распределенный запрос-агрегацию через серию локальных запросов.

Помимо локального для каждого микросервиса хранилища, мы так же определяем базу данных на уровне сервиса-агрегатора, в
которую мы будем складывать результаты локальных записей. При такой схеме, координатор подписывается на события,
исходящие из каждого микросервиса и держит данные в актуальном состоянии.

[Нажми, чтобы перейти к продолжению](#transactional-outbox)

---

Справка

- https://microservices.io/patterns/data/cqrs.html

---

### Transactional Outbox

![transactional outbox](https://microservices.io/i/patterns/data/ReliablePublication.png)

---

В обоих рассмотренных шаблонах, очень важно уметь одновременно записывать данные в локальное хранилище и отправлять
событие. При ошибке в записи и/или отправке события на одном из двух этапов, существует риск оставить систему в
неконсистентном состоянии. Поэтому нам очень важно уметь записывать данные в хранилище и отправлять события в
транзакционной манере.

Простыми словами, мы хотим получить гарантию того, что всегда случится один из двух случаев:

1. данные сохранятся в бд И событие отправится
2. данные НЕ сохранятся в бд И событие НЕ отправится

---

**Transactional Outbox** предоставляет решение для атомарной записи в хранилище и отправки сообщения.

В этом нам помогут транзакции самой базы данных:

1. Помимо основной таблицы для хранения данных, мы заводим _outbox_ таблицу, в которую будем складывать данные о
   событиях
2. При записи данных в обычную таблицу, в той же транзакции мы делаем запись и в outbox таблицу
3. В отдельном процессе, сервис регулярно запрашивает outbox таблицу о новых записях
4. При появлении новых записей, процесс отправляет сообщение и помечает запись как отправленную

При таком подходе, даже если в шаге 4 одна из отправок будет неуспешна, мы можем попытаться повторить его снова, что
_eventually_ предоставит нам _at-least-once_ гарантию доставки сразу для хранилища и отправки события.

---

В [Saga: Choreography](#option-1-saga-choreography), transactional outbox применяется, чтобы обеспечить атомарность
локальной транзакции и отправки события о запуске следующей или компенсации предыдущей транзакции.

В [CQRS](#option-2-cqrs), transactional outbox используется, чтобы атомарно отправить событие сервису-агрегатору вместе
с локальной записью.

---

Справка:

- https://microservices.io/patterns/data/transactional-outbox.html
- https://softwaremill.com/microservices-101/

---

### Сервис-координатор и REST API

Теперь, когда мы разобрались в архитектуре системы, давайте поговорим о наших сервисах.

В каждом из вариантов вам предстоит написать два REST API и один сервис-координатор.

Каждый из REST API отвечает за взаимодействие с одним типом сущностей и ничего не должен знать про другой REST сервис.
Всё межсервисное взаимодействие должно происходить через сервис-координатор и посредством отправки событий через Kafka
топики.

---

В итоге у вас должна получиться цельная система, которая выполняет конкретную функцию. При этом не обязательно, чтобы
это было что-то серьезное, можете дать волю воображению и расчехлить мемчики.

Если же вам лень что-то придумывать или нужен фундамент для размышлений, то можно отталкиваться от примеров ниже:

| Система      | Координатор       | API 1     | API 2    |
|--------------|-------------------|-----------|----------|
| Туроператор  | Букинг туров      | Отели     | Билеты   |
| E-commerce   | История заказов   | Заказы    | Оплата   |
| Доставка еды | Обработка заказов | Рестораны | Доставка |

---

#### Спецификация

1. В [solution.md](solution.md) представлено краткое описание системы, указан выбор варианта (Saga vs CQRS).

2. Описан конкретный сценарий взаимодействия между сервисами, от получения запроса на координаторе и до конечного ответа
   пользователю. Что происходит, когда запрос идет не по плану?

<u>Минимальные требования к REST API:</u>

- у каждого сервиса должно быть собственное хранилище, определена схема
- сервис должен предоставлять API для взаимодействия с сущностями (например, определены CRUD методы, имеется Swagger)
- предоставлен механизм для заполнения данных (серия cURL запросов, python-скрипт, etc.) для ручной проверки

<u>Минимальные требования к сервису-координатору:</u>

- собственное хранилище, определена схема
- сервис должен предоставлять API для воспроизведения целевого сценария (REST метод, имеется Swagger)

---

#### Баллы:

- сервис-координатор, два REST API сервиса: по 50 баллов за сервис, в сумме 150
- телеметрия, логирование: 25 баллов (по 8.33 за каждый сервис)
- тесты: 25 баллов (по 8.33 за каждый сервис)

Максимум можно получить 200 баллов. Удачи

---

Место для всех ссылок и не только:

- https://microservices.io/patterns/microservices.html


- https://en.wikipedia.org/wiki/ACID
- https://en.wikipedia.org/wiki/Eventual_consistency
- https://microservices.io/articles/dark-energy-dark-matter/dark-matter/prefer-acid-over-base.html


- https://microservices.io/post/patterns/2023/07/29/service-collaboration-patterns.html
- https://microservices.io/patterns/data/saga.html
- https://microservices.io/patterns/data/cqrs.html

- https://microservices.io/patterns/data/transactional-outbox.html
- https://softwaremill.com/microservices-101/


- https://medium.com/@ali.gelenler/architectural-microservices-patterns-saga-outbox-and-cqrs-with-kafka-25469d75c18c

<br>
<p align="center">
   <img src="./.img/nothing_to_see_here.jpeg" alt="nothing to see here" width="400">
</p>
